# Pythonä»£ç è§£æå™¨æ¶æ„è®¾è®¡

## ğŸ“‹ æ¦‚è¿°

é‡æ„åçš„ `PythonCodeParserUtil` é‡‡ç”¨äº†æ¸…æ™°çš„åˆ†å±‚æ¶æ„å’Œç­–ç•¥æ¨¡å¼ï¼Œå¤§å¤§æå‡äº†ä»£ç çš„å¯è¯»æ€§ã€å¯ç»´æŠ¤æ€§å’Œå¯æ‰©å±•æ€§ã€‚

## ğŸ—ï¸ æ•´ä½“æ¶æ„

```
PythonCodeParserUtil
â”œâ”€â”€ ğŸ“¦ å¸¸é‡å®šä¹‰å±‚
â”‚   â”œâ”€â”€ RegexPatterns (æ­£åˆ™è¡¨è¾¾å¼å¸¸é‡)
â”‚   â””â”€â”€ CodeBlockMarkers (ä»£ç å—æ ‡è®°)
â”œâ”€â”€ ğŸ”„ å¤„ç†æµç¨‹å±‚
â”‚   â”œâ”€â”€ CodeCleaner (ä»£ç æ¸…ç†å™¨)
â”‚   â”œâ”€â”€ LineFilter (è¡Œè¿‡æ»¤å™¨)
â”‚   â””â”€â”€ ParsersChain (è§£æå™¨é“¾)
â”œâ”€â”€ ğŸ¯ è§£æå™¨å±‚ (ç­–ç•¥æ¨¡å¼)
â”‚   â”œâ”€â”€ ArithmeticExpressionParser (å››åˆ™è¿ç®—)
â”‚   â”œâ”€â”€ FunctionWithIndexParser (å¸¦ç´¢å¼•å‡½æ•°)
â”‚   â”œâ”€â”€ FunctionCallParser (åŸºæœ¬å‡½æ•°è°ƒç”¨)
â”‚   â”œâ”€â”€ DirectFunctionCallParser (ç›´æ¥å‡½æ•°è°ƒç”¨)
â”‚   â”œâ”€â”€ ArrayAccessParser (æ•°ç»„è®¿é—®)
â”‚   â””â”€â”€ AssignmentParser (èµ‹å€¼è¡¨è¾¾å¼)
â”œâ”€â”€ ğŸ”§ è¾…åŠ©å·¥å…·å±‚
â”‚   â”œâ”€â”€ ArithmeticDetector (ç®—æœ¯è¿ç®—æ£€æµ‹)
â”‚   â”œâ”€â”€ ValueTypeDetector (å€¼ç±»å‹æ£€æµ‹)
â”‚   â”œâ”€â”€ ValueParser (å€¼è§£æå™¨)
â”‚   â””â”€â”€ ParameterTokenizer (å‚æ•°åˆ†è¯å™¨)
â””â”€â”€ ğŸ­ æ„å»ºå™¨å±‚
    â””â”€â”€ ExecutableBuilder (JavaExecutableæ„å»ºå™¨)
```

## ğŸ¨ è®¾è®¡æ¨¡å¼

### 1. ç­–ç•¥æ¨¡å¼ (Strategy Pattern)
æ¯ç§Pythonè¯­æ³•éƒ½æœ‰å¯¹åº”çš„è§£æå™¨å®ç° `StatementParser` æ¥å£ï¼š
```java
private interface StatementParser {
    boolean canParse(String line);
    JavaExecutable parse(String line, int stepNum);
    String getParserName();
}
```

### 2. è´£ä»»é“¾æ¨¡å¼ (Chain of Responsibility)
è§£æå™¨æŒ‰ä¼˜å…ˆçº§é¡ºåºç»„æˆé“¾æ¡ï¼Œä¾æ¬¡å°è¯•è§£æï¼š
```java
private static final List<StatementParser> PARSERS = Arrays.asList(
    new ArithmeticExpressionParser(),
    new FunctionWithIndexParser(),
    new FunctionCallParser(),
    // ... å…¶ä»–è§£æå™¨
);
```

### 3. å»ºé€ è€…æ¨¡å¼ (Builder Pattern)
é€šè¿‡ `ExecutableBuilder` æä¾›æµç•…çš„APIæ„å»ºJavaæ‰§è¡ŒæŒ‡ä»¤ï¼š
```java
JavaExecutable executable = ExecutableBuilder.createFunctionExecutable()
    .withStepNum(stepNum)
    .withFunctionName(functionName)
    .withOutputName(varName)
    .build();
```

## ğŸ“Š æ ¸å¿ƒç»„ä»¶è¯¦è§£

### 1. è§£æå™¨é“¾ (ParsersChain)
- **èŒè´£**: ç®¡ç†æ‰€æœ‰è§£æå™¨ï¼ŒæŒ‰ä¼˜å…ˆçº§é¡ºåºå°è¯•è§£æ
- **ä¼˜åŠ¿**: æ–°å¢è§£æå™¨åªéœ€æ·»åŠ åˆ°åˆ—è¡¨ä¸­ï¼Œæ— éœ€ä¿®æ”¹ä¸»é€»è¾‘
- **æ‰©å±•**: æ”¯æŒåŠ¨æ€è°ƒæ•´è§£æå™¨ä¼˜å…ˆçº§

### 2. è¯­å¥è§£æå™¨ (StatementParser)
æ¯ä¸ªè§£æå™¨ä¸“æ³¨äºå¤„ç†ç‰¹å®šç±»å‹çš„Pythonè¯­å¥ï¼š

| è§£æå™¨ | å¤„ç†è¯­æ³• | ç¤ºä¾‹ |
|--------|----------|------|
| ArithmeticExpressionParser | å››åˆ™è¿ç®— | `result = a + b` |
| FunctionWithIndexParser | å¸¦ç´¢å¼•å‡½æ•°è°ƒç”¨ | `data = getData("param")[-1]` |
| FunctionCallParser | åŸºæœ¬å‡½æ•°è°ƒç”¨ | `result = getData("param")` |
| **DirectFunctionCallParser** | **ç›´æ¥å‡½æ•°è°ƒç”¨ï¼ˆå«åµŒå¥—ï¼‰** | `vis_textblock("text", func()[0])` |
| ArrayAccessParser | æ•°ç»„è®¿é—® | `latest = data[-1]` |
| AssignmentParser | å˜é‡èµ‹å€¼ | `name = "value"` |

### ğŸ†• æ–°å¢åŠŸèƒ½ï¼šåµŒå¥—å‡½æ•°è°ƒç”¨æ”¯æŒ

**DirectFunctionCallParser** ç°åœ¨æ”¯æŒå¤æ‚çš„åµŒå¥—å‡½æ•°è°ƒç”¨ï¼ŒåŒ…æ‹¬ï¼š
- **å¤šé‡åµŒå¥—**: `func1(func2(func3("param")))`
- **å¸¦ç´¢å¼•çš„åµŒå¥—**: `process(getData("param")[0], getConfig()["key"])`
- **æ··åˆå‚æ•°ç±»å‹**: `display(123, "text", func(), [1,2], {"key": "value"})`

**æ ¸å¿ƒæŠ€æœ¯**:
- `FunctionCallDetector`: æ™ºèƒ½æ£€æµ‹å‡½æ•°è°ƒç”¨è¾¹ç•Œ
- `FunctionCallInfo`: å°è£…è§£æç»“æœ
- **æ‹¬å·åŒ¹é…ç®—æ³•**: æ­£ç¡®å¤„ç†å¼•å·å†…çš„æ‹¬å·å’ŒåµŒå¥—ç»“æ„

### 3. å‚æ•°åˆ†è¯å™¨ (ParameterTokenizer)
- **èŒè´£**: è§£æå¤æ‚çš„åµŒå¥—å‚æ•°ç»“æ„
- **ç‰¹æ€§**: 
  - æ”¯æŒæ‹¬å·ã€æ–¹æ‹¬å·ã€å¤§æ‹¬å·çš„åµŒå¥—
  - æ­£ç¡®å¤„ç†å¼•å·å†…çš„é€—å·å’Œæ‹¬å·
  - çŠ¶æ€æœºç®¡ç†è§£æçŠ¶æ€
  - **ğŸ”§ Bugä¿®å¤**: è§£å†³äº†å¼•å·å†…æ‹¬å·å¯¼è‡´å‚æ•°æˆªæ–­çš„é—®é¢˜

### ğŸ› æœ€æ–°Bugä¿®å¤ï¼šå¼•å·å†…æ‹¬å·å¤„ç†

**é—®é¢˜æè¿°**:
- åŸé—®é¢˜ï¼š`"è¥ä¸šæ”¶å…¥(å…ƒ)"` è¢«è§£æä¸º `"è¥ä¸šæ”¶å…¥(å…ƒ]`
- åŸå› ï¼šå¼•å·å†…çš„æ‹¬å·é”™è¯¯åœ°å½±å“äº†å¤–å±‚æ‹¬å·è®¡æ•°

**ä¿®å¤æ–¹æ¡ˆ**:
- æ”¹è¿› `TokenizerState` çš„çŠ¶æ€ç®¡ç†é€»è¾‘
- å¼•å·å†…çš„æ‹¬å·ä¸å‚ä¸å¤–å±‚æ‹¬å·è®¡æ•°
- åªåœ¨é¡¶å±‚ä¸”éå¼•å·å†…æ‰è¿›è¡Œå‚æ•°åˆ†å‰²
- ç¡®ä¿å­—ç¬¦ä¸²å‚æ•°çš„å®Œæ•´æ€§

**ä¿®å¤æ•ˆæœ**:
```java
// ä¿®å¤å‰ï¼šè¾“å…¥å‚æ•°ï¼š[result_2, "è¥ä¸šæ”¶å…¥(å…ƒ]  âŒ
// ä¿®å¤åï¼šè¾“å…¥å‚æ•°ï¼š[result_2, "è¥ä¸šæ”¶å…¥(å…ƒ)"] âœ…
```

### 4. å€¼ç±»å‹æ£€æµ‹å’Œè§£æ
- **ValueTypeDetector**: è¯†åˆ«å­—ç¬¦ä¸²ã€åˆ—è¡¨ã€å­—å…¸ç­‰æ•°æ®ç±»å‹
- **ValueParser**: é’ˆå¯¹ä¸åŒç±»å‹æä¾›ä¸“é—¨çš„è§£æé€»è¾‘

## ğŸš€ ä¼˜åŠ¿å¯¹æ¯”

### é‡æ„å‰ vs é‡æ„å

| æ–¹é¢ | é‡æ„å‰ | é‡æ„å |
|------|--------|--------|
| **ä»£ç ç»“æ„** | å•ä¸€å·¨å¤§æ–¹æ³•ï¼Œé€»è¾‘æ··åˆ | æ¸…æ™°åˆ†å±‚ï¼ŒèŒè´£å•ä¸€ |
| **å¯è¯»æ€§** | éœ€è¦é˜…è¯»æ•´ä¸ªæ–¹æ³•æ‰èƒ½ç†è§£ | é€šè¿‡ç±»åå’Œæ–¹æ³•åå³å¯ç†è§£åŠŸèƒ½ |
| **å¯ç»´æŠ¤æ€§** | ä¿®æ”¹ä¸€ä¸ªåŠŸèƒ½å¯èƒ½å½±å“å…¶ä»– | æ¯ä¸ªè§£æå™¨ç‹¬ç«‹ï¼Œå½±å“èŒƒå›´å¯æ§ |
| **å¯æ‰©å±•æ€§** | æ·»åŠ æ–°è¯­æ³•éœ€è¦ä¿®æ”¹ä¸»é€»è¾‘ | åªéœ€æ–°å¢è§£æå™¨åˆ°é“¾ä¸­ |
| **å¯æµ‹è¯•æ€§** | éš¾ä»¥è¿›è¡Œå•å…ƒæµ‹è¯• | æ¯ä¸ªç»„ä»¶å¯ç‹¬ç«‹æµ‹è¯• |
| **é”™è¯¯å®šä½** | é”™è¯¯éš¾ä»¥å®šä½åˆ°å…·ä½“åŠŸèƒ½ | é”™è¯¯æ—¥å¿—æ˜¾ç¤ºå…·ä½“è§£æå™¨ |

## ğŸ” ä½¿ç”¨ç¤ºä¾‹

### 1. è§£æåŸºæœ¬å‡½æ•°è°ƒç”¨
```python
result = getData("param1")
```
**å¤„ç†æµç¨‹**:
1. `LineFilter` ç¡®è®¤ä¸æ˜¯ç©ºè¡Œæˆ–æ³¨é‡Š
2. `ParsersChain` ä¾æ¬¡å°è¯•è§£æå™¨
3. `FunctionCallParser.canParse()` è¿”å› true
4. `FunctionCallParser.parse()` åˆ›å»º JavaExecutable
5. `ParameterTokenizer` è§£æå‚æ•° `"param1"`

### 2. è§£æå¤æ‚å‚æ•°
```python
result = function(getData("param1"), [1,2,3], {"key": "value"})
```
**å¤„ç†æµç¨‹**:
1. `FunctionCallParser` è¯†åˆ«å‡½æ•°è°ƒç”¨æ¨¡å¼
2. `ParameterTokenizer` åˆ†è¯ä¸ºä¸‰ä¸ªå‚æ•°ï¼š
   - `getData("param1")`
   - `[1,2,3]`
   - `{"key": "value"}`
3. ä¿æŒå‚æ•°çš„åµŒå¥—ç»“æ„å®Œæ•´

## ğŸ“ˆ æ‰©å±•æŒ‡å—

### æ·»åŠ æ–°çš„Pythonè¯­æ³•æ”¯æŒ

1. **åˆ›å»ºæ–°è§£æå™¨**:
```java
private static class NewSyntaxParser implements StatementParser {
    @Override
    public boolean canParse(String line) {
        // åˆ¤æ–­é€»è¾‘
    }
    
    @Override
    public JavaExecutable parse(String line, int stepNum) {
        // è§£æé€»è¾‘
    }
}
```

2. **æ·»åŠ åˆ°è§£æå™¨é“¾**:
```java
private static final List<StatementParser> PARSERS = Arrays.asList(
    new NewSyntaxParser(),  // æ·»åŠ æ–°è§£æå™¨
    new ArithmeticExpressionParser(),
    // ... å…¶ä»–è§£æå™¨
);
```

3. **æ·»åŠ ç›¸åº”çš„æ­£åˆ™è¡¨è¾¾å¼**:
```java
private static class RegexPatterns {
    static final Pattern NEW_SYNTAX = Pattern.compile("...");
}
```

### è‡ªå®šä¹‰è§£æé€»è¾‘

- ä¿®æ”¹ `ValueTypeDetector` æ”¯æŒæ–°çš„æ•°æ®ç±»å‹
- æ‰©å±• `ValueParser` å¢åŠ æ–°çš„è§£ææ–¹æ³•
- åœ¨ `ExecutableBuilder` ä¸­æ·»åŠ æ–°çš„æ„å»ºå™¨ç±»å‹

## ğŸ›¡ï¸ æœ€ä½³å®è·µ

1. **å•ä¸€èŒè´£**: æ¯ä¸ªè§£æå™¨åªå¤„ç†ä¸€ç§è¯­æ³•æ¨¡å¼
2. **ä¼˜å…ˆçº§æ’åº**: å°†æ›´å…·ä½“çš„æ¨¡å¼æ”¾åœ¨è§£æå™¨é“¾å‰é¢
3. **é”™è¯¯å¤„ç†**: åœ¨æ¯ä¸ªè§£æå™¨ä¸­æ·»åŠ è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
4. **æ—¥å¿—è®°å½•**: ä½¿ç”¨ä¸åŒçš„æ—¥å¿—çº§åˆ«è®°å½•è§£æè¿‡ç¨‹
5. **æµ‹è¯•è¦†ç›–**: ä¸ºæ¯ä¸ªè§£æå™¨ç¼–å†™ç‹¬ç«‹çš„å•å…ƒæµ‹è¯•

## ğŸ¯ æ€»ç»“

é‡æ„åçš„æ¶æ„å…·æœ‰ä»¥ä¸‹æ ¸å¿ƒä¼˜åŠ¿ï¼š

- **ğŸ” æ¸…æ™°æ€§**: ä»£ç ç»“æ„ä¸€ç›®äº†ç„¶ï¼Œæ˜“äºç†è§£
- **ğŸ”§ å¯ç»´æŠ¤æ€§**: ä¿®æ”¹ç‰¹å®šåŠŸèƒ½ä¸ä¼šå½±å“å…¶ä»–éƒ¨åˆ†
- **ğŸ“ˆ å¯æ‰©å±•æ€§**: æ·»åŠ æ–°åŠŸèƒ½åªéœ€å®ç°æ¥å£å¹¶æ³¨å†Œ
- **ğŸ§ª å¯æµ‹è¯•æ€§**: æ¯ä¸ªç»„ä»¶éƒ½å¯ä»¥ç‹¬ç«‹æµ‹è¯•
- **ğŸš€ æ€§èƒ½**: è§£æå™¨é“¾æ¨¡å¼æé«˜äº†è§£ææ•ˆç‡
- **ğŸ“ å¯è¯»æ€§**: é€šè¿‡å‘½åå’Œæ³¨é‡Šæä¾›æ¸…æ™°çš„ä»£ç æ–‡æ¡£

è¿™ç§è®¾è®¡ä½¿å¾—Pythonä»£ç è§£æå™¨ä¸ä»…åŠŸèƒ½å¼ºå¤§ï¼Œè€Œä¸”æ˜“äºç»´æŠ¤å’Œæ‰©å±•ï¼Œä¸ºåç»­çš„åŠŸèƒ½å¢å¼ºå¥ å®šäº†åšå®çš„åŸºç¡€ã€‚ 